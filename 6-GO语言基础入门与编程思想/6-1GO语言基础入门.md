# 配置国内镜像

Goproxy China

[Go 1.13 及以上（推荐）](https://goproxy.cn/#usage-go-113-and-above-recommended)

打开你的终端并执行

```shell
$ go env -w GO111MODULE=on
$ go env -w GOPROXY=https://goproxy.cn,direct
```

完成。

[macOS 或 Linux](https://goproxy.cn/#usage-macos-or-linux)

打开你的终端并执行

```shell
$ export GO111MODULE=on
$ export GOPROXY=https://goproxy.cn
```

或者

```shell
$ echo "export GO111MODULE=on" >> ~/.profile
$ echo "export GOPROXY=https://goproxy.cn" >> ~/.profile
$ source ~/.profile
```

完成。

[Windows](https://goproxy.cn/#usage-windows)

打开你的 PowerShell 并执行

```shell
C:\> $env:GO111MODULE = "on"
C:\> $env:GOPROXY = "https://goproxy.cn"
```

或者

```shell
1. 打开“开始”并搜索“env”
2. 选择“编辑系统环境变量”
3. 点击“环境变量…”按钮
4. 在“<你的用户名> 的用户变量”章节下（上半部分）
5. 点击“新建…”按钮
6. 选择“变量名”输入框并输入“GO111MODULE”
7. 选择“变量值”输入框并输入“on”
8. 点击“确定”按钮
9. 点击“新建…”按钮
10. 选择“变量名”输入框并输入“GOPROXY”
11. 选择“变量值”输入框并输入“https://goproxy.cn”
12. 点击“确定”按钮
```

完成。

# IDE

- Goland / Intellij Idea+GO插件
- vscode

## 枚举类型

```go
func enums() {
	//普通枚举类型
	const (
		red   = 0
		green = 1
		blue  = 2
	)

	//自增型枚举值
	fmt.Println(red, green, blue)

	const (
		cpp = iota
		_
		python
		golang
		javascript
	)

	fmt.Println(cpp, python, golang, javascript)

	//b, kb, mb, gb, tb, pb
	const (
		b = 1 << (10 * iota)
		kb
		mb
		gb
		tb
		pb
	)
	fmt.Println(b, kb, mb, gb, tb, pb)
}
```

运行结果

```go
0 1 2                                                   
0 2 3 4                                                 
1 1024 1048576 1073741824 1099511627776 1125899906842624
```

## 文件读取与判空

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	const filename = "abc.txt"
	constens, err := ioutil.ReadFile(filename)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("%s\n", constens)
	}
}
```

或者（if的条件语句里可以赋值，if的条件里的赋值的变量作用域就在这个if语句里）

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	const filename = "abc.txt"
	if constens, err := ioutil.ReadFile(filename); err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf("%s\n", constens)
	}
}

```

## switch

Switch会自动break，除非使用fallthrough.

switch后面可以没有表达式，只需在case里面加就可以

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func grade(source int) string {
	g := ""
	switch {
	case source < 0 || source > 100:
		panic(fmt.Sprintf("Wrong source: %d", source))
	case source < 60:
		g = "F"
	case source <= 80:
		g = "B"
	case source <= 90:
		g = "A"
	case source <= 100:
		g = "A"
	}

	return g
}

func main() {

	fmt.Println(grade(0))
	fmt.Println(grade(60))
	fmt.Println(grade(70))
	fmt.Println(grade(80))
	fmt.Println(grade(90))
	fmt.Println(grade(100))
	fmt.Println(grade(120))

}
```

运行结果

```go
F                                                    
B                                                    
B                                                    
B                                                    
A                                                    
A                                                    
panic: Wrong source: 120                             
                                                     
goroutine 1 [running]:                               
main.grade(0xa9b0d8?)                                
        D:/GolandProjects/learnGo/branch.go:12 +0xa5 
main.main()                                          
        D:/GolandProjects/learnGo/branch.go:40 +0x2af

Process finished with the exit code 2
```

　**panic（运行时恐慌）是一种只会在程序运行时才回抛出来的异常。在panic被抛出之后，如果没有在程序里添加任何保护措施的话，程序就会在打印出panic的详情，终止运行。**

## GO语言 for 用法

```go
func convertToBin(n int) string {
	result := ""
	for ; n > 0; n /= 2 {
		lsb := n % 2
		result = strconv.Itoa(lsb) + result
	}

	return result

}

func printFile(filename string) {
	file, err := os.Open(filename)
	if err != nil {
		panic(err)
	}
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}
}

func forover() {
	for {
		fmt.Println("abc")
	}
}
```

## GO函数

**函数定义**

Go 语言函数定义格式如下：

```go
func function_name( [parameter list] ) [return_types] {
   函数体
}
```

函数定义解析：

- func：函数由 func 开始声明
- function_name：函数名称，参数列表和返回值类型构成了函数签名。
- parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。
- return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。
- 函数体：函数定义的代码集合。

```go
package main

import "fmt"

// 如果函数执行出错，那么把错误信息传递给error，交给使用者进行处理
func eval(a, b int, op string) (int, error) {
	switch op {
	case "+":
		return a + b, nil
	case "-":
		return a - b, nil
	case "*":
		return a * b, nil
	case "/":
		//return a / b
		q, _ := div2(a, b)
		return q, nil
	default:
		return 0, fmt.Errorf("unsupported operation: %s", op)
	}
}

// 函数可以返回多个值
func div(a, b int) (int, int) {
	return a / b, a % b
}

//同时函数返回可以给返回值取名,这里返回两个值，第一个返回值取名q， 第二个返回值取名r
func div2(a, b int) (q, r int) {
	q = a / b
	r = a % b
	//return q, r
	//	或者直接
	return
}

func main() {
	if result, err := eval(3, 4, "x"); err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Println(result)
	}
	qd, rd := div2(22, 42)
	fmt.Println(qd, rd) // 0 22
}

```

```go
Error: unsupported operation: x
0 22
```



## 函数式编程

```go
package main

import (
	"fmt"
	"math"
	"reflect"
	"runtime"
)

// 如果函数执行出错，那么把错误信息传递给error，交给使用者进行处理
func eval(a, b int, op string) (int, error) {
	switch op {
	case "+":
		return a + b, nil
	case "-":
		return a - b, nil
	case "*":
		return a * b, nil
	case "/":
		//return a / b
		q, _ := div2(a, b)
		return q, nil
	default:
		return 0, fmt.Errorf("unsupported operation: %s", op)
	}
}

// 函数可以返回多个值
func div(a, b int) (int, int) {
	return a / b, a % b
}

//同时函数返回可以给返回值取名,这里返回两个值，第一个返回值取名q， 第二个返回值取名r
func div2(a, b int) (q, r int) {
	q = a / b
	r = a % b
	//return q, r
	//	或者直接
	return
}

// 函数式编程
func apply(op func(int, int) int, a, b int) int {
	p := reflect.ValueOf(op).Pointer() // 获取函数指针
	opName := runtime.FuncForPC(p).Name()
	fmt.Printf("Calling function %s with args (%d, %d)\t", opName, a, b)
	return op(a, b)
}

func pow(a, b int) int {
	return int(math.Pow(float64(a), float64(b)))
}

func main() {
	if result, err := eval(3, 4, "x"); err != nil {
		fmt.Println("Error:", err)
	} else {
		fmt.Println(result)
	}
	qd, rd := div2(22, 42)
	fmt.Println(qd, rd) // 0 22

	fmt.Println(apply(pow, 3, 4))

	//这里也可以用匿名函数
	fmt.Println(apply(
		func(i int, i2 int) int {
			return int(math.Pow(float64(i), float64(i2)))
		}, 3, 4,
	))
}

```

执行结果

```go
Error: unsupported operation: x
0 22                                                      
Calling function main.pow with args (3, 4)      81        
Calling function main.main.func1 with args (3, 4)       81
```

## 函数重载？函数的默认参数？

这些都没有，GO没有这些花哨的东西。有的只是一个可变参数列表

```go
package main

import (
	"fmt"
)

func sum(numbers ...int) int {
	s := 0
	for i := range numbers {
		s += numbers[i]
	}

	return s
}

func main() {
	fmt.Println(sum(1, 2, 3, 4, 5, 6))		// 21
}

```

## 函数语法要点

- 返回值类型写在最后面
- 可以返回多个值
- 函数可以作为参数
- 没有默认参数，没有可选参数
- 没有函数重载，操作符重载
